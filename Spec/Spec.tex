% $Author: Benjamin $
% $Date: 2011-12-21 14:28:33 +0200 $
% $Revision: 28563 $

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================

\chapter{Spec}

A Spec is a static way to describe a user interface. Used as a presenter, it is a major element of UI and specific model reuse.

In this chapter, I will talk about the Spec Interpreter and how to specify model and UI, and more useful than that, how to reuse existing model and UI.

\section{Code}

The code is available on squeaksource:
\begin{code}{}
Gofer new
	squeaksource: 'DirtyExperiments';
	package: 'Spec';
	load
\end{code}

\section{Spec structure and Spec Interpretor}

\subsection{Spec Structure}

To have a static structure easily inspectable, we have decided to use an array. It avoids to have to implement our own parser, and can be analyzed regardless of the implementation of Smalltalk.

A spec is composed of a receiver which is the first element of the Spec. If the first element is a class name symbol, it will be turn into an instance of this class by the interpreter. Then follow selectors and arguments. For this part, the spec is considered as a stack: each time a selector is read, as many arguments as needed by the selector are pulled and analyzed (see the following example).

%stupid indentation is used to have a render almost aligned
\begin{method}{Example of a spec}
internSpec	^ {#PluggableListMorph.	    	#model:.			  	  #model.			#getListSelector:.	  #getList.			#getIndexSelector:.	#getIndex.			#setIndexSelector:.	#setIndex:.			#wrapSelector:.	  	 #wrapItem:.			#hResizing:.			#spaceFill.			#vResizing:.			#spaceFill		}
\end{method} 

As the specs are defined on class side, we have introduced a specific keyword \#model to create the binding between an instance and its spec.

\subsection{Spec Interpreter}

The goal of the Spec Interpreter is to build an instance starting from a spec.

So it iterates on a spec and recursively build each part of the spec.
Right now, for instance creation, it basically takes the name of a class to create an instance (as seen in the previous example), but a better abstraction could be done by using a Dictionary with keywords as key and morphic classes as values. It allows to separate the morphic part from the presenter, and to simply change the binding to be able to create other interfaces with the same presenter (a dictionary for seaside objects by example).

\begin{method}{Example of a recursive spec}
internSpec	^	{  #PanelMorph.			#changeTableLayout.			#listDirection:. #bottomToTop.			#addMorph:.   { #model. #listModel. #internSpec.	 }.			#addMorph:.	  { #model. #textModel. #internSpec. 	}.			#vResizing:. 	#spaceFill.			#hResizing:. 	#spaceFill.	}.
\end{method} 

\section{Models and presenters construction}

\subsection{ComposableModel}

ComposableModel is an abstract class which is the superclass of all applicative models used with specs.

There is a small API used to handle spec and the connection between the instances and their specs.

\begin{itemize}
	\item morph: an instance variable used to store the UI once the interpreter have created it.
	\item internSpec: this is the default spec. The mechanism assumes each applicative model have such a method on class side.
	\item title: this method return the title of the window used to render the presenter.
\end{itemize}

Then , each model have to define his own entry and exit points used to bind them together.

\subsection{Basic Models}

There is an applicative model for each basic UI widget \ben{now only list, text and button} with their entry point for each customizable behavior of the widget \ben{not yet full coverage}

\paragraph{ListComposableModel} It is the model used to model a list.
Now my entry points are:
\begin{itemize}
	\item listHolder: a value holder which contains a list of elements to display.
	\item wrapHolder: a value holder which contains a block used to wrap item from the list.
\end{itemize}
My exit point is:
\begin{itemize}
	\item selectionHolder: a selection value holder. It contains the index of the current selection and the current selected object.
\end{itemize}

\paragraph{TextComposableModel} It is the model used to model a text area.
Now my entry points are:
\begin{itemize}
	\item textHolder: a value holder which contains the text displayed (it's also an exit point).
	\item actionToPerformHolder: a value holder which contains a block performed when the modified text is saved.
\end{itemize}
There are also entry points for colorization:
\begin{itemize}	
	\item aboutToStyleHolder: this value holder is evaluated to determine is the text should be colorize or not. It should return a boolean.
	\item behaviorHolder: this holder contains the class or metaclass related to the current text, for a good colorization.
\end{itemize}

\paragraph{ButtonComposableModel} It is the model used to model a button.
Now my entry points are:
\begin{itemize}
	\item actionHolder: a value holder which contains a block performed when button is clicked.
	\item labelHolder: a value holder which contains a the label of the button.
	\item stateHolder: a value holder containing a boolean which determine if the button is active or not.
	\item enabledHolder: a value holder containing a boolean which determine if the button is enabled or not.
	\end{itemize}

\subsection{Composition}

This is the most important point of the spec. The ease to reuse models and/or presenters.
In this section, I will show you how to build a little browser of methods ( like senders/implementors ) and how to reuse this browser to build a classes and methods browser ( like a code browser ).

\subsubsection{Methods Browser}

A methods browser is composed of two areas: a list, and a text zone. And the entry point is the list of methods provided.

So let's define a MethodBrowser class

\begin{classdef}{MethodBrowser class}
ComposableModel subclass: #MethodBrowser	instanceVariableNames: 'listHolder listModel textModel'	classVariableNames: ''	poolDictionaries: ''	category: 'Spec-Examples'
\end{classdef}

I let you write accessors. The will be needed by the presenter.
I will just provide you a setter example, because there is a little trick:

\begin{method}{MethodBrowser>>\#listHolder:}
MethodBrowser>>#listHolder: anHolder		listHolder := anHolder.	listModel listHolder: anHolder
\end{method}

The trick is to think to also set the list holder of the list model when the list holder is changed. This way, we ensure that a each every moment, the holder of the browser and the holder of the list model is the same.

So now we have the entry point and the models. So lets make the connections between them.

\begin{method}{MethodBrowser>>\#listHolder:}
MethodBrowser>>#initialize	"Initialization code for MethodBrowser"	| textHolder behaviorHolder |		super initialize.	listModel := ListComposableModel new.	self listHolder: {} asValueHolder.		textHolder := ComposableValueHolder on: (listModel selectionHolder) do: [:index :selection | selection contents 		ifNil: [ '' ]		ifNotNil: [:m | m sourceCode ]].		behaviorHolder := ComposableValueHolder on: (listModel selectionHolder) do: [:index :selection | selection contents 		ifNil: [ nil ]		ifNotNil: [:m | m methodClass ]].		textModel := TextComposableModel textHolder: textHolder.

	textModel behaviorHolder: behaviorHolder.	textModel aboutToStyleHolder contents: [ true ].
\end{method}
Lets explain what ComposableValueHolder is.

\paragraph{ComposableValueHolder} is a special value holder used to transform the value of another value holder. As an example, lets have a look at: 
\begin{code}{}
textHolder := ComposableValueHolder on: (listModel selectionHolder) do: [:index :selection | selection contents 		ifNil: [ '' ]		ifNotNil: [:m | m sourceCode ]].
\end{code}

Here we need a link between the methods list and the text area (when a method is selected, the text zone have to display its source code).

So we have a value holder which changes each time another value holder changes.

Now that links are created, we have to specify the spec on class side:

\begin{method}{MethodBrowser class>>\#internSpec:}
MethodBrowser>>#internSpec	^{ #PanelMorph.			#changeTableLayout.			#listDirection:. #bottomToTop.			#addMorph:. {#model. #listModel. #internSpec.}.			#addMorph:. {#model. #textModel. #internSpec.}.			#vResizing:. #spaceFill.			#hResizing:. #spaceFill.}.
\end{method}
We specify the layout to be a column, with submorphs added form top to bottom.
And then for each model, we add its spec recursively.

So if you evaluate
\begin{code}{}
| browser |
browser := MethodBrowser new.browser openWithSpec.
\end{code}
you should have a window like the \figref{fig:methodBrowser1}.

\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser1}
	\caption{Our browser with an empty list}
	\figlabel{fig:methodBrowser1}
\end{center}
\end{figure}

And then, if you do
\begin{code}{}
browser  listHolder contents: (ComposableModel methodDict values , ListComposableModel methodDict values).
\end{code}
The list should automatically be updated, and looks like \figref{fig:methodBrowser2}.
\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser2}
	\caption{Our browser with list of methods}
	\figlabel{fig:methodBrowser2}
\end{center}
\end{figure}

\newpage
And if you select a method, its source code should appear, like \figref{fig:methodBrowser3}

\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser3}
	\caption{Our browser with a method selected}
	\figlabel{fig:methodBrowser3}
\end{center}
\end{figure}

We are almost done, only the window's title is still wrong.
So we will define
\begin{method}{MethodBrowser class>>\#title}
MethodBrowser class>>#title

	^ 'Method Browser'
\end{method}

So now, if you re-evaluate the code, you should have a window like \figref{fig:methodBrowser4}

\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser4}
	\caption{Now with a nice title}
	\figlabel{fig:methodBrowser4}
\end{center}
\end{figure}

\subsection{Classes and methods browser}

Now, we want to build a classes and methods browser. To do that, we need a list for classes, and a methods browser. And previously, the entry point is a list, but this time, a list of methods.

\begin{classdef}{ClassMethodBrowser class}
ComposableModel subclass: #ClassMethodBrowser	instanceVariableNames: 'listHolder listModel methodModel'	classVariableNames: ''	poolDictionaries: ''	category: 'Spec-Examples'
\end{classdef}

As previously, I let you wrote the accessors. And as previously, we have to ensure the holder from the browser and the holder from the list is the same.

\begin{method}{ClassMethodBrowser>>\#listHolder:}
ClassMethodBrowser>>#listHolder: anHolder		listHolder := anHolder.	listModel listHolder: anHolder
\end{method}

Now we have to create the link. It's simpler here than previously because there is only one link to create between the list of classes and the method browser:

\begin{method}{ClassMethodBrowser>>\#initialize}
ClassMethodBrowser>>#initialize
	"Initialization code for ClassMethodBrowser"	| listHolder2 |		super initialize.		listHolder := {} asValueHolder.	listModel := ListComposableModel new.	listModel listHolder: listHolder.		methodModel := MethodBrowser new.	listHolder2 := ComposableValueHolder on: (listModel selectionHolder) do: [:index :selection | selection contents ifNotNil: [:c | c methodDict values sort: [:a :b | a selector < b selector]]].	methodModel listHolder: listHolder2.	methodModel listModel wrapHolder contents: [:method | method selector ].
\end{method}

So now, lets do the spec. Firstly, let's create the top row, with the two lists

\begin{method}{ClassMethodBrowser class>>\#topSpec}
ClassMethodBrowser class>>#topSpec
	^{ #PanelMorph.			#changeTableLayout.			#listDirection:. #rightToLeft.			#addMorph:. {#model. #listModel. #internSpec.}.			#addMorph:. {#model. #methodModel. #listModel. #internSpec.}.			#vResizing:. #spaceFill.			#hResizing:. #spaceFill.}.
\end{method}

And now we can do the interSpec:

\begin{method}{ClassMethodBrowser class>>\#interSpec}
ClassMethodBrowser class>>#interSpec
	^ { #PanelMorph.			#changeTableLayout.			#listDirection:. #bottomToTop.			#addMorph:. self topSpec.			#addMorph:. {#model. #methodModel. #textModel. #internSpec.}.			#vResizing:. #spaceFill.			#hResizing:. #spaceFill.}.
\end{method}
In each spec, we call the spec of our internal models.
Lastly, we can specify a title for the window:
\begin{method}{ClassMethodBrowser class>>\#title}
ClassMethodBrowser class>>#title

	^ 'Class Method Browser'
\end{method}
Then, if you evaluate

\begin{code}{}
| browser |
browser := ClassMethodBrowser new.browser openWithSpec.browser listHolder contents: (Smalltalk allClasses).
\end{code}
you will get a nice browser like \figref{fig:methodBrowser5}.


\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser5}
	\caption{Our classes and methods browser with a method selected}
	\figlabel{fig:methodBrowser5}
\end{center}
\end{figure}

\section{Conclusion}

As conclusion, you have now tools to create quickly Uis and to reuse them.
So you have to keep in mind that you tool can be reuse a think of providing an API to allow that.

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: